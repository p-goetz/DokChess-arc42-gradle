title=8. Konzeptetype=pagestatus=published~~~~~~Dieser Abschnitt beschreibt allgemeine Strukturen und Aspekte, die systemweit gelten. Darüber hinaus stellt er verschiedene technische Lösungskonzepte vor.* [8.1 Abhängigkeiten zwischen Modulen](#8.1)* [8.2 Schach-Domänenmodell](#8.2)* [8.3	Benutzungsoberfläche](#8.3)* [8.4 Plausibilisierung und Validierung](#8.4)* [8.5 Ausnahme- und Fehlerbehandlung](#8.5)* [8.6 Logging, Protokollierung, Tracing](#8.6)* [8.7 Testbarkeit](#8.7)<a name="8.1" class="anchor"></a>## 8.1 Abhängigkeiten zwischen ModulenDokChess soll zum Experimentieren und zum Erweitern der Engine einladen (→ 1. Aufgabenstellung). Die Module sind daher über Schnittstellen lose gekoppelt. Module sind Implementierungen von Java-Schnittstellen. Java-Klassen, welche Teile benötigen, signalisieren dies über entsprechende Methoden `set<Modul>(<Schnittstelle> ...)`. Sie kümmern sich nicht selbst um das Auflösen einer Abhängigkeit, indem sie beispielsweise Exemplare mit new bauen, oder eine Factory bemühen. Stattdessen löst der Verwender die Abhängigkeiten auf, indem er passende Implementierungen erzeugt und über die Setter-Methoden zusammensteckt (Dependency Injection, kurz DI).Dies ermöglicht die Verwendung alternativer Implementierungen innerhalb des Rahmens DokChess und das Hinzufügen von Funktionalität über das Decorator-Pattern [Gamma+94]. Auch Lösungsansätze aspektorientierter Programmierung (AOP), die auf Dynamic Proxies basieren, sind auf Java Interfaces leicht anwendbar. Nicht zuletzt wirkt sich dieser Umgang mit Abhängigkeiten positiv auf die Testbarkeit (→ Konzept 8.7) aus.DokChess verzichtet auf die Verwendung eines speziellen DI Frameworks. Die Module werden im Quelltext hart verdrahtet, allerdings nur in Unit-Tests und Glue-Code (z.B. der Main-Klasse). Um experimentierfreudigen Anwendern bezüglich einer konkreten DI-Implementierung freie Wahl zu lassen, findet insbesondere keine annotationsgetriebene Konfiguration statt. IchDa die Java-Module reine POJOs (Plain old Java objects) sind, steht einer Konfiguration beispielsweise mit dem Spring Framework oder CDI (Contexts and Dependency Injection for the Java EE Platform) nichts im Wege.<a name="8.2" class="anchor"></a>## 8.2 Schach-Domänenmodell_Das Schachspiel wird zwischen zwei Gegnern gespielt, die abwechselnd ihre Figuren auf einem quadratischen Spielbrett, Schachbrett genannt, ziehen."_ (Zitat aus den FIDE-Regeln)Die verschiedenen Systemteile tauschen schachspezifische Daten aus. Hierzu zählen vor allem die Situation auf dem Brett (Stellung), sowie gegnerische und eigene Züge. Als Aufruf- und Rückgabeparameter werden in allen Modulen dieselben Klassen verwendet. An dieser Stelle finden Sie einen groben Überblick über diese Datenstrukturen und deren Abhängigkeiten untereinander. Details sind in der Quelltextdokumentation (javadoc) enthalten. Die Klassen und Aufzählungstypen (enums) befinden sich im Paket `de.dokchess.allgemein`.Eine Schachfigur ist gekennzeichnet durch Farbe (schwarz oder weiß) und Art (König, Dame, ...). Im Domänenmodell von DokChess weiß eine Figur nicht, wo sie steht. Die Klasse ist unveränderlich (immutable) wie alle anderen im Domänenmodell auch.![Eine Figur hat eine Farbe und eine Art](images/Abb09_18_Figur.png "Eine Figur hat eine Farbe (z.B. weiß) und eine Art (z.B. Bauer)") *Bild: Eine Figur hat eine Farbe (z.B. weiß) und eine Art (z.B. Bauer)*Das Schachbrett besteht aus 8 x 8 Feldern die in 8 Reihen (1-8) und 8 Linien (a-h) angeordnet sind. Die Klasse `Feld` beschreibt ein ebensolches. Da ein Feld maximal von einer Figur besetzt sein kann, reicht für die Angabe eines Zuges, von wo nach wo gezogen wird. Einzige Ausnahme bildet die Umwandlung eines Bauern auf der gegnerischen Grundlinie, da der Spieler selbst entscheidet, in welche Figur er umwandelt (in der Regel, aber nicht zwingend, eine Dame). Rochadezüge werden als Königszüge über zwei Felder in die entsprechende Richtung repräsentiert.![Ein Zug geht von einem Feld zu einem Feld](images/Abb09_19_Zug.png "Ein Zug geht von einem Feld zu einem Feld") *Bild: Ein Zug geht von einem Feld zu einem Feld*Die Klasse `Stellung` stellt die aktuelle Situation auf dem Brett dar. Vor allem sind das die Figuren auf dem Brett, das intern als zweidimensionales Array (8 x 8) implementiert ist. Falls ein Feld unbesetzt ist, steht null im Array. Zur Komplettierung der Spielsituation gehört die Information, wer am Zug ist, ob noch Rochaden möglich sind und ob en passant geschlagen werden kann.![Die Klasse Stellung](images/Abb09_20_Stellung.png "Die Klasse Stellung (Ausschnitt, Details wie Rochade fehlen)")*Bild 9.20 Die Klasse Stellung (Ausschnitt, Details wie Rochade fehlen)* Die Klasse `Stellung` ist ebenfalls unveränderlich, die Methode `fuehreZugAus()` liefert eine neue Stellung mit der veränderten Spielsituation zurück (→ Entscheidung 9.2 „Sind Stellungsobjekte veränderlich oder nicht?“).<a name="8.3" class="anchor"></a>## 8.3	BenutzungsoberflächeDokChess verfügt selbst über keine grafische Oberfläche, sondern agiert über das XBoard-Protokoll mit der Außenwelt (→ Entscheidung 9.1). Im Folgenden wird dies kurz skizziert.Das Protokoll ist textbasiert, ein Starten von DokChess in einer Kommandozeile (Unix-Shell, Windows-Eingabeaufforderung, ...) erlaubt eine Interaktion mit der Engine, wenn man die wichtigsten XBoard-Kommandos beherrscht (siehe Bild in Abschnitt 4). Die folgende Tabelle zeigt einen Beispieldialog, alle Kommandos werden mit einer neuen Zeile abgeschlossen). Standardmäßig spielt eine Engine schwarz, man kann das über die Protokollbefehl "white" ändern.*Tabelle: Beispielkommunikation zwischen einem Client und DokChess (XBoard)*| Client -> DokChess | DokChess -> Client | Bemerkung ||--------------------|--------------------|-----------|| `xboard`           | &nbsp;             | Client will XBoard-Protokoll verwenden (erforderlich, da Engines teilweise andere, teileweise sogar mehrere Protokolle verstehen) || &nbsp;             | (neue Zeile)       | &nbsp; || `protover 2`       | &nbsp;             |	Protokollversion 2 || &nbsp;             | `feature done=1`   | zeilenweise Mitteilung über zusätzliche Features der Engine (hier: keine) || `e2e4`             | &nbsp;             | Weiß zieht Bauer e2-e4 || &nbsp;             | `move b8c6`        | Schwarz (DokChess) zieht Springer b8-c6 || `quit`             | &nbsp;             | Der Client beendet das Spiel (DokChess terminiert) |Das Protokoll selbst wird in [Mann+2009] detailliert beschrieben, für die Implementierung in DokChess ist das Subsystem XBoard-Protokoll zuständig (→ Bausteinsicht 5.2).Die typische Verwendung von DokChess ist das Vorschalten eines grafischen Schachfrontends wie Arena (siehe Bild unten), das die Züge des Gegners über eine komfortable Oberfläche entgegennimmt und diese in Form von XBoard-Kommandos wie in der Tabelle oben an DokChess weitergibt (Spalte "Client -> DokChess") und die Antworten (Spalte "DokChess -> Client") grafisch umsetzt.![DokChess im Schach-Frontend Arena unter Windows](images/Abb09_21_FrontendArena.png "DokChess im Schach-Frontend Arena unter Windows")*Bild: DokChess im Schach-Frontend Arena unter Windows*<a name="8.4" class="anchor"></a>## 8.4 Plausibilisierung und ValidierungDokChess ist, vereinfacht ausgedrückt, ein Algorithmus, es antwortet auf Züge des Gegners mit eigenen Zügen. Für die Überprüfung von Eingaben sind zwei Kanäle relevant: das XBoard-Protokoll für interaktive Benutzereingaben des Gegners sowie Eröffnungsbibliotheken in Form von Dateien.Eingaben, die über das XBoard-Protokoll eingehen, werden vom entsprechenden Subsystem geparst. Unbekannte oder nicht implementierte Kommandos meldet DokChess mit dem XBoard-Kommando "Error" an den Client zurück. Im Falle eines Zugkommandos wird mit Hilfe des Spielregeln-Subsystem überprüft, ob der Zug regelkonform ist. Unzulässige Züge meldet DokChess mit dem XBoard-Kommando "Illegal move" an den Client zurück. Bei Verwendung eines grafischen Frontends sollte dieser Fall nicht auftreten, da diese typischerweise nur gültige Züge absetzen. Der Fall ist eher für die Interaktion per Kommandozeile relevant (→ 8.3 „Benutzungsoberfläche“). Beim Aufbau einer Stellung überprüft DokChess die Einhaltung des Protokolls, nicht aber, ob die Position zulässig ist. Im Extremfall kann das dazu führen, dass das Engine-Subsystem im Spielverlauf Fehler wirft (z.B. wenn man keine Könige auf das Brett stellt).Bei den Eröffnungsbibliotheken prüft DokChess lediglich, ob es die Datei öffnen und einlesen kann. Im Fehlerfall (konkret z.B.: Datei nicht gefunden) wird eine Exception geworfen (→ 8.5). Beim Einlesen quittiert das Eröffnung-Subsystem von ihm erkannte Probleme (z.B. ungültiges Format) ebenfalls mit einem Laufzeitfehler. Inhaltlich prüft es die Bibliothek jedoch nicht. Falls beispielsweise unzulässige Züge für eine Stellung hinterlegt sind, wird das nicht erkannt. Für die Qualität der Bibliothek ist der Anwender selbst verantwortlich (siehe → 3. Kontextabgrenzung). Im Extremfall antwortet die Engine mit einem ungültigen Zug.<a name="8.5" class="anchor"></a>## 8.5 Ausnahme- und FehlerbehandlungDokChess verfügt über keine eigene Oberfläche. Es muss Probleme daher nach außen signalisieren. Die Methoden der DokChess-Subsysteme werfen dazu Runtime Exceptions, im Falle des Engine-Subsystems bei asynchroner Zugermittlung zusätzlich Fehlernachrichten (`onError`). Eigene Erweiterungen (beispielsweise eine eigene Zugauswahl) müssen entsprechend implementiert sein, Checked Exceptions (zum Beispiel `java.io.IOException`) etwa sind geeignet zu verpacken. Die wenigen erwarteten Exceptions bei DokChess zeigt das javadoc der entsprechenden Methoden und Konstruktoren an. Probleme beim Einlesen einer Eröffnungsbibliothek etwa, oder beim Versuch der Zugermittlung innerhalb der Engine bei ungültiger Stellung (falls erkannt). Alle übrigen Exceptions wären Programmierfehler (bitte melden Sie solche Fälle unter https://github.com/DokChess/).Das XBoard-Subsystem fängt sämtliche Exceptions und kommuniziert sie über das XBoard-Protokoll nach außen (Kommando "tellusererror"). Ein grafisches Frontend visualisiert sie in der Regel in einem Fehler-Dialog oder einer Alert-Box, das folgende Bild zeigt das für das Schachfrontend Arena.![DokChess-Fehlermeldung visualisiert durch Arena](images/Abb09_22_FehlermeldungArena.png "DokChess-Fehlermeldung visualisiert durch Arena")*Bild: DokChess-Fehlermeldung visualisiert durch Arena: Datei nicht gefunden*DokChess arbeitet dann "normal" weiter, wobei der Anwender selbst entscheidet, ob ein Fortfahren in der konkreten Situation sinnvoll ist. Beispielsweise könnte er ohne Eröffnungsbibliothek weiterspielen.<a name="8.6" class="anchor"></a>## 8.6 Logging, Protokollierung, TracingFür Verbesserungen und Erweiterungen von DokChess durch Dritte sind die vorhandenen Analysemöglichkeiten von Interesse, insbesondere bei Fehlverhalten. Die Funktionalität selbst lässt sich gut mit Unit-Tests überprüfen. Das gilt insbesondere für die korrekte Implementierung der Spielregeln, für die Spielweise der Engine (→ 8.7 „Testbarkeit“) und auch für eigene Erweiterungen.Innerhalb von DokChess gibt es daher keine feinkörnigen Logging-Ausgaben; Lösungen wie log4j kommen nicht zum Einsatz. Auf diese Weise wird eine Abhängigkeit zu einer Fremdbibliothek, die sich durch den ganzen Quelltext ziehen würde, vermieden und der Code nicht durch diesen Aspekt verschmutzt.Für die Kommunikation zwischen Client und DokChess über das XBoard-Protokoll besteht neben der interaktiven Bedienung über eine Shell (→ 8.3 Benutzungsoberfläche) oft die Möglichkeit, den Client die Konversation protokollieren zu lassen. Gängige Schachfrontends erlauben dies über das Schreiben von Log-Dateien und/oder die simultane Anzeige eines Protokollfensters während des Spiels. Das folgende Bild zeigt diese Funktionalität exemplarisch für Arena.![Protokollfenster zum XBoard-Protokoll in Arena](images/Abb09_23_ProtokollfensterArena.png "Protokollfenster zum XBoard-Protokoll in Arena")*Bild: Protokollfenster zum XBoard-Protokoll in Arena*Solche Werkzeuge sind von unschätzbarem Wert, wenn die Engine hängt und unklar ist, was auf dem XBoard-Protokoll gelaufen ist. Aufgrund ihrer Verfügbarkeit wurde auf die Implementierung eines Kommunikationsprotokoll-Tracings innerhalb von DokChess verzichtet.<a name="8.7" class="anchor"></a>## 8.7 TestbarkeitNichts ist peinlicher für eine Engine als ein unzulässiger Zug.Die Funktionalität der einzelnen Module von DokChess wird durch umfangreiche Unit-Tests sichergestellt. In der Quelltextstruktur ist neben dem Ordner src/main, wo die Java-Quelltexte der Module abgelegt sind, ein Ordner `src/test` zu finden. Er enthält ein Spiegelbild der Paketstruktur, und in den entsprechenden Paketen Unit-Tests zu den Klassen, die mit JUnit 4 realisiert sind.Reine Unit-Tests, die einzelne Klassen prüfen, heißen wie die Klasse selbst, nur hinten mit Test. Darüber hinaus gibt es Tests, die das Zusammenspiel von Modulen prüfen, und im Extremfall das ganze System. Mit Hilfe solcher Tests wird die korrekte Spielweise von DokChess überprüft. Unterhalb von `src/integTest` liegen aufwändigere, länger laufende Integrationstests. Hierzu zählt etwa das Durchspielen ganzer Partien.Bei vielen Tests muss eine Stellung als Aufrufparameter vorgelegt werden. Hier kommt die Forsyth-Edwards-Notation (kurz FEN) zum Einsatz. Diese Notation erlaubt die Angabe einer kompletten Spielsituation als kompakte Zeichenkette ohne Zeilenumbruch und ist daher wie geschaffen für den Einsatz in automatisierten Test.Die Grundstellung wird in FEN beispielsweise so notiert:`"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"`Kleine Buchstaben stehen für schwarze, große für weiße Figuren, es werden die englischen Bezeichnungen (Rook für Turm, Pawn für Bauer, ...) verwendet.![Beispielstellung](images/Abb09_24_Beispielstellung.png "Beispielstellung")*Bild: Beispielstellung (weiß am Zug ist matt)*Die Spielsituation in Bild oben mit weiß vor dem 79. Zug, wobei 30 Halbzüge lang keine Figur geschlagen und kein Bauer bewegt wurde, sähe in FEN so aus:`"6r1/6pp/7r/1B5K/1P3k2/N7/3R4/8 w - - 30 79"`und liest sich "6 Felder frei, schwarzer Turm, Feld frei, neue Reihe ...".Details zur Notation sind beispielsweise bei Wikipedia nachzulesen. Die Klasse Stellung verfügt über einen Konstruktor, der eine Zeichenkette in FEN akzeptiert. Die `toString`-Methode der Klasse liefert ebenfalls FEN.Neben Tests auf korrekte Funktionalität wird auch überprüft, ob die geforderten Antwortzeiten für exemplarische Spielsituationen eingehalten werden können. Dies erfolgt mit der `@Test`-Annotation und deren Timeout-Parameter. Der Erfolg dieser Tests hängt von der eingesetzten Hardware ab.